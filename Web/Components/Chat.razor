@page "/"
@inject NavigationManager Navigation
@inject IJSRuntime JS
@implements IAsyncDisposable

<PageTitle>T.H.U.V.U. Chat</PageTitle>

<div class="chat-container @(_fileViewerOpen ? "file-viewer-active" : "") @(_orchestrationOpen ? "orchestration-active" : "")">
    <!-- Sidebar with file tree and config -->
    <aside class="sidebar">
        <!-- File Tree Section -->
        <div class="sidebar-section file-tree-section @(_workspaceExpanded ? "expanded" : "")">
            <div class="section-header">
                <h3>üìÅ Workspace</h3>
                <div class="header-buttons">
                    <button class="btn-icon" @onclick="RefreshFileTree" title="Refresh">üîÑ</button>
                    <button class="btn-icon" @onclick="ToggleWorkspace" title="@(_workspaceExpanded ? "Shrink" : "Expand")">
                        @(_workspaceExpanded ? "‚¨ÜÔ∏è" : "‚¨áÔ∏è")
                    </button>
                </div>
            </div>
            <FileTree RootPath="." 
                      HubConnection="@_hubConnection" 
                      SessionId="@_sessionId"
                      OnFileSelect="@HandleFileSelect" 
                      @ref="_fileTree" />
        </div>
        
        <div class="sidebar-section">
            <h3>Status</h3>
            <div class="config-item">
                @if (_connected)
                {
                    <span class="badge badge-connected">‚óè Connected</span>
                }
                else
                {
                    <span class="badge badge-disconnected">‚óè Disconnected</span>
                }
            </div>
            @if (!string.IsNullOrEmpty(_reconnectMessage))
            {
                <div class="config-item reconnect-status">
                    <span class="reconnect-message">@_reconnectMessage</span>
                </div>
            }
            @if (_hasOrchestration && !_orchestrationOpen)
            {
                <div class="config-item">
                    <button class="btn btn-small btn-secondary" @onclick="ShowOrchestration">
                        üé≠ Show Orchestration
                    </button>
                </div>
            }
        </div>
        
        <div class="sidebar-section">
            <div class="section-header">
                <h3>Configuration</h3>
                <button class="btn-icon" @onclick="@(() => OpenSettings())" title="Open Settings">‚öôÔ∏è</button>
            </div>
            <div class="config-item">
                <span class="config-label">Model:</span>
                <span class="config-value">@_model</span>
            </div>
            <div class="config-item">
                <span class="config-label">Host:</span>
                <span class="config-value">@_hostUrl</span>
            </div>
            <div class="config-item">
                <span class="config-label">Work Dir:</span>
                <span class="config-value" title="@_workDir">@TruncatePath(_workDir)</span>
            </div>
            <div class="config-item">
                <span class="config-label">MCP:</span>
                <span class="config-value @(_mcpEnabled ? "enabled" : "disabled")">@(_mcpEnabled ? "Enabled" : "Disabled")</span>
            </div>
            <div class="config-item">
                <span class="config-label">RAG:</span>
                <span class="config-value @(_ragEnabled ? "enabled" : "disabled")">@(_ragEnabled ? "Enabled" : "Disabled")</span>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>Session</h3>
            <div class="config-item">
                <span class="config-label">ID:</span>
                <span class="config-value">@_sessionId</span>
            </div>
            <div class="config-item">
                <span class="config-label">Messages:</span>
                <span class="config-value">@_messages.Count</span>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>Context Usage</h3>
            @if (_contextUsage != null)
            {
                <div class="context-usage">
                    <div class="context-bar">
                        <div class="context-fill @GetContextBarClass()" style="width: @(_contextUsage.UsagePercent)%"></div>
                    </div>
                    <div class="context-stats">
                        <span class="context-percent">@(_contextUsage.UsagePercent.ToString("F1"))%</span>
                        <span class="context-tokens">@_contextUsage.TotalTokens.ToString("N0") / @_contextUsage.MaxContextLength.ToString("N0")</span>
                    </div>
                </div>
            }
            else
            {
                <div class="config-item">
                    <span class="config-value text-muted">No data yet</span>
                </div>
            }
        </div>
        
        <div class="sidebar-actions">
            <button class="btn btn-secondary" @onclick="ClearChat" disabled="@_isProcessing">
                üóëÔ∏è Clear Chat
            </button>
        </div>
    </aside>
    
    <!-- Main chat area -->
    <div class="chat-main">
        <!-- Messages -->
        <div class="messages-container" @ref="_messagesContainer">
            @if (_messages.Count == 0)
            {
                <div class="welcome-message">
                    <h2>Welcome to T.H.U.V.U.</h2>
                    <p>Your local-first AI coding agent. Ask me to help with:</p>
                    <ul>
                        <li>Reading and analyzing code</li>
                        <li>Writing and modifying files</li>
                        <li>Running tests and builds</li>
                        <li>Git operations</li>
                        <li>And much more...</li>
                    </ul>
                </div>
            }
            
            @foreach (var msg in _messages)
            {
                <div class="message @msg.Role">
                    <div class="message-header">
                        <span class="message-role">@GetRoleDisplay(msg.Role)</span>
                        <span class="message-time">@msg.Timestamp.ToString("HH:mm:ss")</span>
                        @if (msg.Role == "assistant" || msg.Role == "tool")
                        {
                            <button class="btn-icon copy-btn" @onclick="() => CopyContent(msg.Content)" title="Copy">üìã</button>
                        }
                    </div>
                    <div class="message-content">
                        @if (msg.IsScreenshot && !string.IsNullOrEmpty(msg.ScreenshotBase64))
                        {
                            <div class="screenshot-container">
                                <img src="data:image/png;base64,@msg.ScreenshotBase64" alt="Browser Screenshot" class="browser-screenshot" />
                            </div>
                        }
                        else if (msg.Role == "tool")
                        {
                            var (formattedContent, isTruncated) = FormatToolResult(msg.Content);
                            var (formattedArgs, _) = FormatToolResult(msg.ToolArgs ?? "");
                            
                            @if (msg.IsSubAgentDelegation)
                            {
                                // Special rendering for sub-agent delegation results
                                <div class="subagent-result depth-@msg.AgentDepth">
                                    <div class="subagent-header">
                                        <span class="subagent-icon">@GetRoleIcon(msg.AgentRole)</span>
                                        <span class="subagent-role">@GetRoleDisplayName(msg.AgentRole)</span>
                                        @if (isTruncated)
                                        {
                                            <span class="tool-truncated">(truncated)</span>
                                        }
                                    </div>
                                    @if (!string.IsNullOrEmpty(formattedArgs))
                                    {
                                        <div class="subagent-task">
                                            <span class="subagent-task-label">Task:</span>
                                            <pre class="subagent-task-content">@formattedArgs</pre>
                                        </div>
                                    }
                                    <div class="subagent-output-section">
                                        <span class="subagent-output-label">Result:</span>
                                        <pre class="subagent-output">@formattedContent</pre>
                                    </div>
                                </div>
                            }
                            else
                            {
                                <div class="tool-result">
                                    <div class="tool-header">
                                        <span class="tool-icon">üîß</span>
                                        <span class="tool-name">@msg.ToolName</span>
                                        @if (isTruncated)
                                        {
                                            <span class="tool-truncated">(truncated)</span>
                                        }
                                    </div>
                                    @if (!string.IsNullOrEmpty(formattedArgs))
                                    {
                                        <div class="tool-args">
                                            <span class="tool-args-label">Arguments:</span>
                                            <pre class="tool-args-content">@formattedArgs</pre>
                                        </div>
                                    }
                                    <div class="tool-output-section">
                                        <span class="tool-output-label">Result:</span>
                                        <pre class="tool-output">@formattedContent</pre>
                                    </div>
                                </div>
                            }
                        }
                        else if (msg.Role == "assistant" || msg.Role == "system")
                        {
                            <MarkdownRenderer Content="@msg.Content" />
                        }
                        else
                        {
                            <pre class="message-text">@msg.Content</pre>
                        }
                    </div>
                </div>
            }
            
            @if (_isProcessing)
            {
                <div class="message assistant streaming">
                    <div class="message-header">
                        <span class="message-role">ü§ñ Assistant</span>
                        <span class="message-status">@_currentStatus</span>
                    </div>
                    <div class="message-content">
                        @if (!string.IsNullOrEmpty(_currentToolName))
                        {
                            var (formattedArgs, _) = FormatToolResult(_currentToolArgs);
                            <div class="tool-progress">
                                <div class="tool-header">
                                    <span class="tool-icon">üîß</span>
                                    <span class="tool-name">@_currentToolName</span>
                                    <span class="tool-status">@_currentToolStatus</span>
                                </div>
                                @if (!string.IsNullOrEmpty(formattedArgs))
                                {
                                    <div class="tool-args">
                                        <span class="tool-args-label">Arguments:</span>
                                        <pre class="tool-args-content">@formattedArgs</pre>
                                    </div>
                                }
                            </div>
                        }
                        <pre class="message-text">@_streamingContent<span class="cursor">‚ñä</span></pre>
                    </div>
                </div>
            }
        </div>
        
        <!-- Input area -->
        <div class="input-area">
            <div class="input-wrapper">
                @if (_showAutocomplete && _suggestions.Count > 0)
                {
                    <div class="autocomplete-dropdown">
                        @for (int i = 0; i < _suggestions.Count; i++)
                        {
                            var idx = i;
                            var suggestion = _suggestions[i];
                            <div class="autocomplete-item @(idx == _selectedSuggestion ? "selected" : "")" 
                                 @onclick="() => SelectSuggestion(idx)">
                                <span class="autocomplete-icon">@suggestion.Icon</span>
                                <span class="autocomplete-text">@suggestion.Text</span>
                                @if (!string.IsNullOrEmpty(suggestion.Description))
                                {
                                    <span class="autocomplete-desc">@suggestion.Description</span>
                                }
                            </div>
                        }
                    </div>
                }
                <div class="textarea-wrapper @(_attachedImageBase64 != null ? "has-attachment" : "")"
                     @ondrop="HandleDrop"
                     @ondrop:preventDefault="true"
                     @ondragover:preventDefault="true">
                    @if (_attachedImageBase64 != null)
                    {
                        <div class="attached-image-preview">
                            <img src="data:@_attachedImageMimeType;base64,@_attachedImageBase64" alt="Attached image" />
                            <button class="remove-attachment" @onclick="RemoveAttachedImage" title="Remove image">‚úï</button>
                            <span class="attachment-name">@_attachedImageName</span>
                        </div>
                    }
                    <textarea 
                        @ref="_inputElement"
                        @bind="_inputText"
                        @bind:event="oninput"
                        @onkeydown="HandleKeyDown"
                        @onkeyup="HandleKeyUp"
                        @onpaste="HandlePaste"
                        placeholder="@(_attachedImageBase64 != null ? "Describe what to analyze in the image..." : "Ask T.H.U.V.U. anything... (Enter to send, Shift+Enter for newline, paste/drop images)")"
                        disabled="@_isProcessing"
                        rows="3">
                    </textarea>
                </div>
                <div class="input-actions">
                    @if (_isProcessing)
                    {
                        <button class="btn btn-cancel" @onclick="CancelRequest">
                            ‚èπÔ∏è Cancel
                        </button>
                    }
                    else
                    {
                        <button class="btn btn-primary" @onclick="SendMessage" disabled="@string.IsNullOrWhiteSpace(_inputText)">
                            üì§ Send
                        </button>
                    }
                </div>
            </div>
            
            <div class="input-footer">
                @if (_usage != null)
                {
                    <div class="token-usage">
                        <span>Tokens: @_usage.Prompt prompt + @_usage.Completion completion = @_usage.Total total</span>
                    </div>
                }
                <div class="shortcuts-hint">
                    <kbd>Enter</kbd> send ¬∑ <kbd>Shift+Enter</kbd> newline ¬∑ <kbd>Esc</kbd> cancel
                </div>
            </div>
        </div>
    </div>
</div>

<!-- File Viewer Panel -->
<FileViewer @ref="_fileViewer" OnClose="@HandleFileViewerClose" />

<!-- Agent Tabs for Orchestration -->
<AgentTabs @ref="_agentTabs" OnClose="@HandleAgentTabsClose" />

<!-- Settings Panel -->
<Settings IsOpen="@_settingsOpen" OnClose="@CloseSettings" OnSettingsChanged="@HandleSettingsChanged" />

<!-- Permission Dialog -->
<PermissionDialog 
    IsOpen="@_permissionDialogOpen" 
    RequestId="@_pendingPermissionRequestId"
    ToolName="@_pendingPermissionToolName"
    Args="@_pendingPermissionArgs"
    OnResponse="@HandlePermissionResponse" />

<!-- Toast container for notifications -->
<div class="toast-container">
    @if (_showCopyToast)
    {
        <div class="toast success">
            ‚úì Copied to clipboard
        </div>
    }
</div>

@code {
    private HubConnection? _hubConnection;
    private ElementReference _messagesContainer;
    private ElementReference _inputElement;
    private FileTree? _fileTree;
    private FileViewer? _fileViewer;
    private AgentTabs? _agentTabs;
    private bool _fileViewerOpen;
    private bool _settingsOpen;
    private bool _orchestrationOpen;
    private bool _hasOrchestration;
    
    // Permission dialog state
    private bool _permissionDialogOpen;
    private string _pendingPermissionRequestId = "";
    private string _pendingPermissionToolName = "";
    private string _pendingPermissionArgs = "";
    
    private string _sessionId = "";
    private string _model = "";
    private string _hostUrl = "";
    private string _workDir = "";
    private bool _mcpEnabled;
    private bool _ragEnabled;
    private bool _connected;
    private string _reconnectMessage = "";
    
    private List<ChatMessageDisplay> _messages = new();
    private string _inputText = "";
    private bool _isProcessing;
    private string _streamingContent = "";
    private string _currentStatus = "";
    private string _currentToolName = "";
    private string _currentToolArgs = "";
    private string _currentToolStatus = "";
    private TokenUsageDisplay? _usage;
    private ContextUsageDisplay? _contextUsage;
    private bool _showCopyToast;
    private bool _workspaceExpanded = false;
    
    // Attached image state
    private string? _attachedImageBase64;
    private string? _attachedImageMimeType;
    private string? _attachedImageName;

    // Autocomplete state
    private bool _showAutocomplete;
    private List<AutocompleteSuggestion> _suggestions = new();
    private int _selectedSuggestion;
    private string _autocompletePrefix = "";

    private bool _initialized;
    private DotNetObjectReference<Chat>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // OnAfterRenderAsync with firstRender=true runs after interactive mode is established
            if (!_initialized)
            {
                _initialized = true;
                // Use a small delay to ensure the circuit is fully established
                await Task.Delay(100);
                await InitializeHubConnection();
                await SetupVisibilityHandler();
            }
        }
    }
    
    private async Task SetupVisibilityHandler()
    {
        _dotNetRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("setupVisibilityHandler", _dotNetRef);
    }
    
    [JSInvokable]
    public async Task OnPageVisibilityChanged(bool isVisible)
    {
        Console.WriteLine($"Page visibility changed: {(isVisible ? "visible" : "hidden")}");
        
        if (isVisible && _hubConnection?.State == HubConnectionState.Disconnected)
        {
            // Page became visible and connection is lost - reconnect
            await TryReconnectAsync();
        }
    }

    private async Task InitializeHubConnection()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(Navigation.ToAbsoluteUri("/agenthub"))
                .WithAutomaticReconnect(new[] { 
                    TimeSpan.Zero,           // Retry immediately
                    TimeSpan.FromSeconds(2), 
                    TimeSpan.FromSeconds(5),
                    TimeSpan.FromSeconds(10),
                    TimeSpan.FromSeconds(30),
                    TimeSpan.FromMinutes(1),
                    TimeSpan.FromMinutes(2),
                    TimeSpan.FromMinutes(5)  // Keep trying for a while
                })
                .Build();
            
            // Configure timeouts for long-running operations
            _hubConnection.ServerTimeout = TimeSpan.FromMinutes(10);
            _hubConnection.KeepAliveInterval = TimeSpan.FromSeconds(30);

            _hubConnection.Reconnecting += error =>
            {
                _connected = false;
                _reconnectMessage = "Reconnecting...";
                InvokeAsync(StateHasChanged);
                return Task.CompletedTask;
            };

            _hubConnection.Reconnected += connectionId =>
            {
                _connected = true;
                _reconnectMessage = "";
                // Re-join session after reconnect
                _ = RejoinSessionAsync();
                InvokeAsync(StateHasChanged);
                return Task.CompletedTask;
            };
            
            _hubConnection.Closed += async ex =>
            {
                _connected = false;
                Console.WriteLine($"Hub connection closed: {ex?.Message}");
                _reconnectMessage = "Connection lost. Attempting to reconnect...";
                await InvokeAsync(StateHasChanged);
                
                // Try to reconnect after a delay if automatic reconnect gave up
                await Task.Delay(5000);
                if (_hubConnection.State == HubConnectionState.Disconnected)
                {
                    await TryReconnectAsync();
                }
            };

            await _hubConnection.StartAsync();
            _connected = true;
            Console.WriteLine("SignalR connected to agenthub");

            // Join session
            var result = await _hubConnection.InvokeAsync<SessionInfo>("JoinSession", null as string);
            _sessionId = result.SessionId;
            Console.WriteLine($"Joined session: {_sessionId}");
            
            if (result.Config != null)
            {
                _model = result.Config.Model ?? "";
                _hostUrl = result.Config.HostUrl ?? "";
                _workDir = result.Config.WorkDirectory ?? "";
                _mcpEnabled = result.Config.McpEnabled;
                _ragEnabled = result.Config.RagEnabled;
            }
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize hub connection: {ex}");
            _connected = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SendMessage()
    {
        Console.WriteLine($"SendMessage called. InputText: '{_inputText}', HubConnection: {_hubConnection != null}, Connected: {_connected}");
        
        // Allow sending with just an image attached (empty message is OK)
        if ((string.IsNullOrWhiteSpace(_inputText) && _attachedImageBase64 == null) || _hubConnection == null)
        {
            Console.WriteLine("SendMessage aborted - empty input or no hub connection");
            return;
        }

        // Hide autocomplete
        _showAutocomplete = false;

        var userMessage = _inputText?.Trim() ?? "";
        var hasImage = _attachedImageBase64 != null;
        var imageBase64 = _attachedImageBase64;
        var imageMimeType = _attachedImageMimeType;
        
        _inputText = "";
        _attachedImageBase64 = null;
        _attachedImageMimeType = null;
        _attachedImageName = null;
        
        // Check for slash commands that should be handled locally
        if (userMessage.StartsWith("/"))
        {
            await HandleSlashCommand(userMessage);
            return;
        }
        
        // Build display content
        var displayContent = hasImage 
            ? (string.IsNullOrWhiteSpace(userMessage) ? "üñºÔ∏è [Image attached for analysis]" : $"üñºÔ∏è {userMessage}")
            : userMessage;
            
        _messages.Add(new ChatMessageDisplay
        {
            Role = "user",
            Content = displayContent,
            Timestamp = DateTime.Now
        });

        _isProcessing = true;
        _streamingContent = "";
        _currentStatus = hasImage ? "Analyzing image..." : "Thinking...";
        _currentToolName = "";
        _currentToolStatus = "";
        StateHasChanged();
        await ScrollToBottom();

        try
        {
            // Use image endpoint if we have an attached image
            IAsyncEnumerable<AgentStreamEvent> stream;
            if (hasImage && imageBase64 != null && imageMimeType != null)
            {
                stream = _hubConnection.StreamAsync<AgentStreamEvent>(
                    "SendMessageWithImage", 
                    _sessionId, 
                    userMessage, 
                    imageBase64, 
                    imageMimeType);
            }
            else
            {
                stream = _hubConnection.StreamAsync<AgentStreamEvent>("SendMessage", _sessionId, userMessage);
            }
            
            await foreach (var evt in stream)
            {
                switch (evt.Type)
                {
                    case "token":
                        _streamingContent += evt.Data;
                        break;
                    case "status":
                        _currentStatus = evt.Data;
                        break;
                    case "tool_progress":
                        _currentToolName = evt.ToolName ?? "";
                        _currentToolStatus = evt.Data;
                        break;
                    case "tool_call":
                        // Finalize any streaming content before starting tool display
                        if (!string.IsNullOrEmpty(_streamingContent))
                        {
                            _messages.Add(new ChatMessageDisplay
                            {
                                Role = "assistant",
                                Content = _streamingContent,
                                Timestamp = DateTime.Now
                            });
                            _streamingContent = "";
                        }
                        // Store tool arguments when a tool call starts
                        _currentToolName = evt.ToolName ?? "";
                        _currentToolArgs = evt.Data;
                        break;
                    case "tool_complete":
                        _currentToolName = "";
                        _currentToolArgs = "";
                        _currentToolStatus = "";
                        break;
                    case "tool_result":
                        // Finalize any streaming content before adding tool result
                        if (!string.IsNullOrEmpty(_streamingContent))
                        {
                            _messages.Add(new ChatMessageDisplay
                            {
                                Role = "assistant",
                                Content = _streamingContent,
                                Timestamp = DateTime.Now
                            });
                            _streamingContent = "";
                        }
                        _messages.Add(new ChatMessageDisplay
                        {
                            Role = "tool",
                            ToolName = evt.ToolName ?? "unknown",
                            ToolArgs = _currentToolArgs,
                            Content = evt.Data,
                            Timestamp = DateTime.Now,
                            IsSubAgentDelegation = evt.ToolName == "delegate_to_agent",
                            AgentRole = evt.ToolName == "delegate_to_agent" ? ExtractSubAgentRole(evt.Data) : null,
                            AgentDepth = evt.ToolName == "delegate_to_agent" ? 1 : 0
                        });
                        _currentToolArgs = ""; // Clear after using
                        break;
                    case "usage":
                        _usage = System.Text.Json.JsonSerializer.Deserialize<TokenUsageDisplay>(evt.Data);
                        break;
                    case "context_usage":
                        _contextUsage = System.Text.Json.JsonSerializer.Deserialize<ContextUsageDisplay>(evt.Data);
                        break;
                    case "context_summarizing":
                        _messages.Add(new ChatMessageDisplay
                        {
                            Role = "system",
                            Content = $"‚ö° {evt.Data}",
                            Timestamp = DateTime.Now
                        });
                        break;
                    case "context_summarized":
                        _messages.Add(new ChatMessageDisplay
                        {
                            Role = "system",
                            Content = $"‚úÖ {evt.Data}",
                            Timestamp = DateTime.Now
                        });
                        break;
                    case "browser_screenshot":
                        _messages.Add(new ChatMessageDisplay
                        {
                            Role = "system",
                            Content = $"![Screenshot](data:image/png;base64,{evt.Data})",
                            IsScreenshot = true,
                            ScreenshotBase64 = evt.Data,
                            Timestamp = DateTime.Now
                        });
                        break;
                    case "permission_request":
                        await HandlePermissionRequest(evt.Data);
                        break;
                    case "done":
                        if (!string.IsNullOrEmpty(_streamingContent))
                        {
                            _messages.Add(new ChatMessageDisplay
                            {
                                Role = "assistant",
                                Content = _streamingContent,
                                Timestamp = DateTime.Now
                            });
                        }
                        break;
                    case "error":
                        _messages.Add(new ChatMessageDisplay
                        {
                            Role = "error",
                            Content = evt.Data,
                            Timestamp = DateTime.Now
                        });
                        break;
                    case "cancelled":
                        _messages.Add(new ChatMessageDisplay
                        {
                            Role = "system",
                            Content = "Request cancelled",
                            Timestamp = DateTime.Now
                        });
                        break;
                }
                StateHasChanged();
                await ScrollToBottom();
            }
        }
        catch (Exception ex)
        {
            _messages.Add(new ChatMessageDisplay
            {
                Role = "error",
                Content = $"Error: {ex.Message}",
                Timestamp = DateTime.Now
            });
        }
        finally
        {
            _isProcessing = false;
            _streamingContent = "";
            _currentStatus = "";
            _currentToolName = "";
            StateHasChanged();
        }
    }

    private async Task CancelRequest()
    {
        if (_hubConnection != null)
        {
            await _hubConnection.InvokeAsync("CancelRequest", _sessionId);
        }
    }

    private async Task ClearChat()
    {
        if (_hubConnection != null)
        {
            await _hubConnection.InvokeAsync("ClearSession", _sessionId);
            _messages.Clear();
            _usage = null;
            StateHasChanged();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        // Handle autocomplete navigation
        if (_showAutocomplete && _suggestions.Count > 0)
        {
            if (e.Key == "ArrowDown")
            {
                _selectedSuggestion = (_selectedSuggestion + 1) % _suggestions.Count;
                return;
            }
            else if (e.Key == "ArrowUp")
            {
                _selectedSuggestion = (_selectedSuggestion - 1 + _suggestions.Count) % _suggestions.Count;
                return;
            }
            else if (e.Key == "Tab")
            {
                // Tab applies suggestion without sending
                await ApplySelectedSuggestion();
                return;
            }
            else if (e.Key == "Escape")
            {
                _showAutocomplete = false;
                return;
            }
            // Note: Enter falls through to send message (autocomplete is hidden first)
        }

        if (e.Key == "Enter" && !e.ShiftKey && !_isProcessing)
        {
            // Hide autocomplete before sending
            _showAutocomplete = false;
            await SendMessage();
        }
        else if (e.Key == "Escape" && _isProcessing)
        {
            await CancelRequest();
        }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        // Don't trigger autocomplete for navigation keys
        if (e.Key == "ArrowUp" || e.Key == "ArrowDown" || e.Key == "ArrowLeft" || e.Key == "ArrowRight" || 
            e.Key == "Escape" || e.Key == "Tab" || e.Key == "Enter")
            return;

        await UpdateAutocomplete();
    }

    private async Task UpdateAutocomplete()
    {
        var text = _inputText ?? "";
        
        // Check for command autocomplete (starts with /)
        if (text.StartsWith("/"))
        {
            var prefix = text;
            _autocompletePrefix = prefix;
            _suggestions = GetCommandSuggestions(prefix);
            _showAutocomplete = _suggestions.Count > 0;
            _selectedSuggestion = 0;
            StateHasChanged();
            return;
        }

        // Check for file path autocomplete
        var lastWord = GetLastWord(text);
        if (ShouldTriggerFileAutocomplete(lastWord))
        {
            _autocompletePrefix = lastWord;
            if (_hubConnection != null)
            {
                try
                {
                    // Strip @ prefix for file search if present
                    var searchPrefix = lastWord.StartsWith("@") ? lastWord[1..] : lastWord;
                    var files = await _hubConnection.InvokeAsync<List<string>>("GetFileSuggestions", _sessionId, searchPrefix);
                    _suggestions = files.Select(f => new AutocompleteSuggestion
                    {
                        Text = lastWord.StartsWith("@") ? "@" + f : f,  // Keep @ prefix in suggestion
                        Icon = f.EndsWith("/") || f.EndsWith("\\") ? "üìÅ" : "üìÑ",
                        Description = ""
                    }).Take(10).ToList();
                    _showAutocomplete = _suggestions.Count > 0;
                    _selectedSuggestion = 0;
                }
                catch
                {
                    _showAutocomplete = false;
                }
            }
            StateHasChanged();
            return;
        }

        _showAutocomplete = false;
        StateHasChanged();
    }

    private List<AutocompleteSuggestion> GetCommandSuggestions(string prefix)
    {
        var commands = new List<AutocompleteSuggestion>
        {
            new() { Text = "/help", Icon = "‚ùì", Description = "Show available commands" },
            new() { Text = "/clear", Icon = "üóëÔ∏è", Description = "Clear conversation" },
            new() { Text = "/exit", Icon = "üö™", Description = "Exit the agent" },
            new() { Text = "/system", Icon = "‚öôÔ∏è", Description = "Set system prompt" },
            new() { Text = "/stream", Icon = "üì°", Description = "Toggle streaming" },
            new() { Text = "/config", Icon = "üîß", Description = "View configuration" },
            new() { Text = "/diff", Icon = "üìù", Description = "Show git diff" },
            new() { Text = "/test", Icon = "üß™", Description = "Run tests" },
            new() { Text = "/run", Icon = "‚ñ∂Ô∏è", Description = "Run a command" },
            new() { Text = "/commit", Icon = "üíæ", Description = "Commit changes" },
            new() { Text = "/push", Icon = "‚¨ÜÔ∏è", Description = "Push to remote" },
            new() { Text = "/pull", Icon = "‚¨áÔ∏è", Description = "Pull from remote" },
            new() { Text = "/rag", Icon = "üîç", Description = "RAG operations" },
            new() { Text = "/mcp", Icon = "üîå", Description = "MCP operations" },
            new() { Text = "/models", Icon = "ü§ñ", Description = "Model management" },
            new() { Text = "/plan", Icon = "üìã", Description = "Plan a task" },
            new() { Text = "/orchestrate", Icon = "üé≠", Description = "Multi-agent orchestration" },
            new() { Text = "/health", Icon = "üíö", Description = "Check service health" },
            new() { Text = "/status", Icon = "üìä", Description = "Show session status" },
        };

        return commands
            .Where(c => c.Text.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
            .Take(8)
            .ToList();
    }

    private string GetLastWord(string text)
    {
        if (string.IsNullOrEmpty(text)) return "";
        
        // Find the last word (after space, or the whole text)
        var lastSpace = text.LastIndexOf(' ');
        return lastSpace >= 0 ? text[(lastSpace + 1)..] : text;
    }

    private bool ShouldTriggerFileAutocomplete(string word)
    {
        if (string.IsNullOrEmpty(word)) return false;
        
        // Trigger on @ followed by anything (for file mentions)
        if (word.StartsWith("@")) return true;
        
        // Also trigger on paths starting with ./ ../ / or containing \ /
        if (word.Length < 2) return false;
        return word.StartsWith("./") || 
               word.StartsWith("../") || 
               word.StartsWith("/") ||
               word.Contains("\\") ||
               word.Contains("/");
    }

    private async Task ApplySelectedSuggestion()
    {
        if (_selectedSuggestion < 0 || _selectedSuggestion >= _suggestions.Count)
            return;

        var suggestion = _suggestions[_selectedSuggestion];
        
        // Replace the prefix with the suggestion
        if (_inputText.StartsWith("/"))
        {
            _inputText = suggestion.Text;
        }
        else
        {
            var lastWord = GetLastWord(_inputText);
            var beforeLastWord = _inputText.Length > lastWord.Length 
                ? _inputText[..^lastWord.Length] 
                : "";
            _inputText = beforeLastWord + suggestion.Text;
        }

        _showAutocomplete = false;
        StateHasChanged();
        await Task.CompletedTask;
    }

    private void SelectSuggestion(int index)
    {
        _selectedSuggestion = index;
        _ = ApplySelectedSuggestion();
    }

    private async Task HandleSlashCommand(string command)
    {
        // Add user message showing the command
        _messages.Add(new ChatMessageDisplay 
        { 
            Role = "user", 
            Content = command, 
            Timestamp = DateTime.Now 
        });
        
        _isProcessing = true;
        _currentStatus = "Executing command...";
        StateHasChanged();
        await ScrollToBottom();

        try
        {
            var stream = _hubConnection!.StreamAsync<AgentStreamEvent>("ExecuteCommand", _sessionId, command);
            var result = new System.Text.StringBuilder();
            
            await foreach (var evt in stream)
            {
                switch (evt.Type)
                {
                    case "command_result":
                        result.AppendLine(evt.Data);
                        break;
                    case "error":
                        result.AppendLine($"‚ùå {evt.Data}");
                        break;
                    case "status":
                        _currentStatus = evt.Data;
                        StateHasChanged();
                        break;
                    
                    // Orchestration events
                    case "orchestration_start":
                        _currentStatus = "Starting orchestration...";
                        StateHasChanged();
                        break;
                        
                    case "orchestration_plan":
                        try
                        {
                            var planData = System.Text.Json.JsonSerializer.Deserialize<OrchestrationPlanData>(evt.Data);
                            if (planData != null && _agentTabs != null)
                            {
                                _agentTabs.StartOrchestration(planData.TaskName, 
                                    planData.Subtasks.Select(s => (s.Id, s.Title)).ToList());
                                _orchestrationOpen = true;
                                _hasOrchestration = true;
                            }
                        }
                        catch { }
                        StateHasChanged();
                        break;
                        
                    case "agent_started":
                        try
                        {
                            var startData = System.Text.Json.JsonSerializer.Deserialize<AgentStartData>(evt.Data);
                            if (startData != null && _agentTabs != null)
                            {
                                _agentTabs.UpdateAgentStatusByTaskId(startData.TaskId, "Running");
                                _agentTabs.AddAgentMessageByTaskId(startData.TaskId, "system", $"üöÄ Starting task...");
                                _currentStatus = $"Working on {startData.TaskId}...";
                            }
                        }
                        catch { }
                        StateHasChanged();
                        break;
                        
                    case "agent_output":
                        try
                        {
                            var outputData = System.Text.Json.JsonSerializer.Deserialize<AgentOutputData>(evt.Data);
                            if (outputData != null && _agentTabs != null && !string.IsNullOrEmpty(outputData.TaskId))
                            {
                                // Streaming output - append to existing message
                                _agentTabs.AppendAgentStreamingByTaskId(outputData.TaskId, outputData.Text);
                            }
                        }
                        catch { }
                        StateHasChanged();
                        break;
                        
                    case "agent_tool_call":
                        try
                        {
                            var toolData = System.Text.Json.JsonSerializer.Deserialize<AgentToolCallData>(evt.Data);
                            if (toolData != null && _agentTabs != null && !string.IsNullOrEmpty(toolData.TaskId))
                            {
                                // Finalize any streaming message before adding tool call
                                _agentTabs.FinalizeAgentStreamingByTaskId(toolData.TaskId);
                                _agentTabs.AddAgentMessageByTaskId(toolData.TaskId, "tool", $"üîß **{toolData.ToolName}**: {toolData.Status}");
                            }
                        }
                        catch { }
                        StateHasChanged();
                        break;
                        
                    case "agent_completed":
                        try
                        {
                            var completeData = System.Text.Json.JsonSerializer.Deserialize<AgentCompleteData>(evt.Data);
                            if (completeData != null && _agentTabs != null)
                            {
                                // Finalize any streaming message
                                _agentTabs.FinalizeAgentStreamingByTaskId(completeData.TaskId);
                                
                                var status = completeData.Success ? "Completed" : "Failed";
                                _agentTabs.UpdateAgentStatusByTaskId(completeData.TaskId, status);
                                
                                var message = completeData.Success 
                                    ? completeData.Result ?? "‚úÖ Task completed successfully"
                                    : $"‚ùå {completeData.Error ?? "Task failed"}";
                                _agentTabs.AddAgentMessageByTaskId(completeData.TaskId, 
                                    completeData.Success ? "assistant" : "error", message);
                            }
                        }
                        catch { }
                        StateHasChanged();
                        break;
                        
                    case "phase_completed":
                        _currentStatus = $"Phase completed: {evt.Data}";
                        StateHasChanged();
                        break;
                        
                    case "orchestration_completed":
                        try
                        {
                            var completeInfo = System.Text.Json.JsonSerializer.Deserialize<OrchestrationCompleteData>(evt.Data);
                            if (completeInfo != null && _agentTabs != null)
                            {
                                var summaryMsg = completeInfo.Success 
                                    ? "‚úÖ All tasks completed successfully!"
                                    : "‚ö†Ô∏è Some tasks failed. See individual agent tabs for details.";
                                _agentTabs.SetMergedResult(summaryMsg);
                            }
                        }
                        catch { }
                        _currentStatus = "";
                        StateHasChanged();
                        break;
                }
            }
            
            // Add result message if there's content
            if (result.Length > 0)
            {
                _messages.Add(new ChatMessageDisplay 
                { 
                    Role = "system", 
                    Content = result.ToString().TrimEnd(), 
                    Timestamp = DateTime.Now 
                });
            }
            
            // Special handling for /clear - clear local messages too
            if (command.StartsWith("/clear", StringComparison.OrdinalIgnoreCase))
            {
                _messages.Clear();
            }
        }
        catch (Exception ex)
        {
            _messages.Add(new ChatMessageDisplay 
            { 
                Role = "error", 
                Content = $"Command failed: {ex.Message}", 
                Timestamp = DateTime.Now 
            });
        }
        finally
        {
            _isProcessing = false;
            _currentStatus = "";
            StateHasChanged();
            await ScrollToBottom();
        }
    }

    private async Task HandleFileSelect(string path)
    {
        if (_hubConnection == null) return;
        
        try
        {
            var result = await _hubConnection.InvokeAsync<FileContentResult>("ReadFile", _sessionId, path);
            if (result.Success)
            {
                if (_fileViewer != null)
                {
                    await _fileViewer.OpenFile(path, result.Content);
                    _fileViewerOpen = true;
                    StateHasChanged();
                }
            }
            else
            {
                // Show error as a message
                _messages.Add(new ChatMessageDisplay
                {
                    Role = "error",
                    Content = $"Could not open file: {result.Error}",
                    Timestamp = DateTime.Now
                });
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading file: {ex.Message}");
        }
    }

    private void HandleFileViewerClose()
    {
        _fileViewerOpen = false;
        StateHasChanged();
    }

    private void HandleAgentTabsClose()
    {
        _orchestrationOpen = false;
        StateHasChanged();
    }
    
    private void ShowOrchestration()
    {
        if (_agentTabs != null && _agentTabs.HasOrchestration)
        {
            _agentTabs.Show();
            _orchestrationOpen = true;
            StateHasChanged();
        }
    }

    private async Task OpenSettings()
    {
        await JS.InvokeVoidAsync("console.log", "OpenSettings called from Blazor");
        _settingsOpen = true;
        StateHasChanged();
    }

    private void CloseSettings()
    {
        Console.WriteLine("CloseSettings called");
        _settingsOpen = false;
        StateHasChanged();
    }

    private async Task HandleSettingsChanged()
    {
        // Reload configuration display
        _model = thuvu.Models.AgentConfig.Config.Model;
        _hostUrl = thuvu.Models.AgentConfig.Config.HostUrl;
        _mcpEnabled = thuvu.Models.McpConfig.Instance.Enabled;
        _ragEnabled = thuvu.Models.RagConfig.Instance.Enabled;
        StateHasChanged();
    }
    
    private async Task HandlePermissionRequest(string? data)
    {
        if (string.IsNullOrEmpty(data)) return;
        
        try
        {
            using var doc = System.Text.Json.JsonDocument.Parse(data);
            var root = doc.RootElement;
            
            _pendingPermissionRequestId = root.GetProperty("requestId").GetString() ?? "";
            _pendingPermissionToolName = root.GetProperty("toolName").GetString() ?? "";
            _pendingPermissionArgs = root.GetProperty("args").GetString() ?? "";
            _permissionDialogOpen = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing permission request: {ex.Message}");
        }
    }
    
    private async Task HandlePermissionResponse(string choice)
    {
        if (_hubConnection != null && !string.IsNullOrEmpty(_pendingPermissionRequestId))
        {
            try
            {
                await _hubConnection.InvokeAsync("RespondToPermission", _sessionId, _pendingPermissionRequestId, choice);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error responding to permission: {ex.Message}");
            }
        }
        
        _permissionDialogOpen = false;
        _pendingPermissionRequestId = "";
        _pendingPermissionToolName = "";
        _pendingPermissionArgs = "";
        StateHasChanged();
    }

    private void ToggleWorkspace()
    {
        _workspaceExpanded = !_workspaceExpanded;
    }
    
    private async Task RefreshFileTree()
    {
        if (_fileTree != null)
        {
            await _fileTree.RefreshTree();
        }
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JS.InvokeVoidAsync("thuvu.scrollToBottom", _messagesContainer);
        }
        catch { }
    }

    private async Task CopyContent(string content)
    {
        try
        {
            await JS.InvokeVoidAsync("thuvu.copyToClipboard", content);
            _showCopyToast = true;
            StateHasChanged();
            
            // Hide toast after 2 seconds
            await Task.Delay(2000);
            _showCopyToast = false;
            StateHasChanged();
        }
        catch { }
    }

    private string GetRoleDisplay(string role) => role switch
    {
        "user" => "üë§ You",
        "assistant" => "ü§ñ Assistant",
        "tool" => "üîß Tool",
        "error" => "‚ùå Error",
        "system" => "‚ÑπÔ∏è System",
        _ => role
    };

    private string TruncatePath(string path, int maxLength = 25)
    {
        if (string.IsNullOrEmpty(path) || path.Length <= maxLength)
            return path;
        return "..." + path[^(maxLength - 3)..];
    }

    private string GetContextBarClass()
    {
        if (_contextUsage == null) return "";
        return _contextUsage.UsagePercent switch
        {
            >= 90 => "critical",
            >= 70 => "warning",
            _ => "normal"
        };
    }
    
    /// <summary>
    /// Format JSON content for display - pretty print with truncation of long field values
    /// </summary>
    private string FormatJsonForDisplay(string content, int maxFieldLength = 500)
    {
        if (string.IsNullOrWhiteSpace(content)) return content;
        
        try
        {
            using var doc = System.Text.Json.JsonDocument.Parse(content);
            var truncated = TruncateJsonElement(doc.RootElement, maxFieldLength);
            return System.Text.Json.JsonSerializer.Serialize(truncated, new System.Text.Json.JsonSerializerOptions 
            { 
                WriteIndented = true 
            });
        }
        catch
        {
            // Not valid JSON, return as-is
            return content;
        }
    }
    
    /// <summary>
    /// Recursively truncate long string values in a JSON element
    /// </summary>
    private object? TruncateJsonElement(System.Text.Json.JsonElement element, int maxFieldLength)
    {
        switch (element.ValueKind)
        {
            case System.Text.Json.JsonValueKind.Object:
                var obj = new Dictionary<string, object?>();
                foreach (var prop in element.EnumerateObject())
                {
                    obj[prop.Name] = TruncateJsonElement(prop.Value, maxFieldLength);
                }
                return obj;
                
            case System.Text.Json.JsonValueKind.Array:
                var arr = new List<object?>();
                foreach (var item in element.EnumerateArray())
                {
                    arr.Add(TruncateJsonElement(item, maxFieldLength));
                }
                return arr;
                
            case System.Text.Json.JsonValueKind.String:
                var str = element.GetString() ?? "";
                if (str.Length > maxFieldLength)
                {
                    return str.Substring(0, maxFieldLength) + $"... ({str.Length - maxFieldLength} more chars)";
                }
                return str;
                
            case System.Text.Json.JsonValueKind.Number:
                if (element.TryGetInt64(out var longVal)) return longVal;
                if (element.TryGetDouble(out var doubleVal)) return doubleVal;
                return element.GetRawText();
                
            case System.Text.Json.JsonValueKind.True:
                return true;
                
            case System.Text.Json.JsonValueKind.False:
                return false;
                
            case System.Text.Json.JsonValueKind.Null:
            default:
                return null;
        }
    }
    
    /// <summary>
    /// Format tool result for display - handles JSON formatting with field truncation
    /// </summary>
    private (string FormattedContent, bool IsTruncated) FormatToolResult(string content, int maxFieldLength = 500)
    {
        if (string.IsNullOrWhiteSpace(content)) return (content, false);
        
        var original = content;
        var formatted = FormatJsonForDisplay(content, maxFieldLength);
        
        // Check if any truncation occurred by comparing lengths (rough heuristic)
        var wasTruncated = formatted.Contains("... (") && formatted.Contains(" more chars)");
        
        return (formatted, wasTruncated);
    }

    /// <summary>
    /// Extract the sub-agent role from a delegate_to_agent result
    /// </summary>
    private string? ExtractSubAgentRole(string resultJson)
    {
        try
        {
            using var doc = System.Text.Json.JsonDocument.Parse(resultJson);
            if (doc.RootElement.TryGetProperty("role", out var roleProp))
            {
                return roleProp.GetString();
            }
        }
        catch { }
        return null;
    }

    /// <summary>
    /// Get a display icon for a sub-agent role
    /// </summary>
    private string GetRoleIcon(string? role)
    {
        return role?.ToLower() switch
        {
            "planner" => "üìã",
            "coder" => "üíª",
            "tester" => "üß™",
            "reviewer" => "üîç",
            "debugger" => "üêõ",
            _ => "ü§ñ"
        };
    }

    /// <summary>
    /// Get a display name for a sub-agent role
    /// </summary>
    private string GetRoleDisplayName(string? role)
    {
        return role?.ToLower() switch
        {
            "planner" => "Planning Agent",
            "coder" => "Coding Agent",
            "tester" => "Testing Agent",
            "reviewer" => "Review Agent",
            "debugger" => "Debugging Agent",
            _ => "Sub-Agent"
        };
    }
    
    private async Task TryReconnectAsync()
    {
        const int maxRetries = 10;
        var retryDelays = new[] { 1000, 2000, 5000, 10000, 30000, 60000 };
        
        for (int i = 0; i < maxRetries && _hubConnection?.State == HubConnectionState.Disconnected; i++)
        {
            try
            {
                _reconnectMessage = $"Reconnecting... (attempt {i + 1}/{maxRetries})";
                await InvokeAsync(StateHasChanged);
                
                await _hubConnection!.StartAsync();
                _connected = true;
                _reconnectMessage = "";
                await RejoinSessionAsync();
                await InvokeAsync(StateHasChanged);
                Console.WriteLine("Successfully reconnected to hub");
                return;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Reconnect attempt {i + 1} failed: {ex.Message}");
                var delay = retryDelays[Math.Min(i, retryDelays.Length - 1)];
                await Task.Delay(delay);
            }
        }
        
        _reconnectMessage = "Unable to reconnect. Please refresh the page.";
        await InvokeAsync(StateHasChanged);
    }
    
    // Image attachment handlers
    private async Task HandlePaste(ClipboardEventArgs e)
    {
        // Try to get image from clipboard via JS interop
        try
        {
            await JS.InvokeVoidAsync("thuvu.handlePasteEvent", _dotNetRef);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling paste: {ex.Message}");
        }
    }
    
    [JSInvokable]
    public void OnImagePasted(string base64, string mimeType, string name)
    {
        _attachedImageBase64 = base64;
        _attachedImageMimeType = mimeType;
        _attachedImageName = name;
        InvokeAsync(StateHasChanged);
    }
    
    private async Task HandleDrop(DragEventArgs e)
    {
        // Handle dropped files via JS interop
        try
        {
            // The actual file reading happens in JS, but we need to handle DataTransfer
            // For now, show a message that drop is being processed
            if (e.DataTransfer?.Files?.Length > 0)
            {
                await JS.InvokeVoidAsync("console.log", "Files dropped, processing...");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling drop: {ex.Message}");
        }
    }
    
    private void RemoveAttachedImage()
    {
        _attachedImageBase64 = null;
        _attachedImageMimeType = null;
        _attachedImageName = null;
        StateHasChanged();
    }
    
    private async Task RejoinSessionAsync()
    {
        if (_hubConnection == null || string.IsNullOrEmpty(_sessionId)) return;
        
        try
        {
            // Re-join the existing session to restore state
            var result = await _hubConnection.InvokeAsync<SessionInfo>("JoinSession", _sessionId);
            if (result.SessionId == _sessionId)
            {
                Console.WriteLine($"Re-joined session: {_sessionId}");
            }
            else
            {
                // Session was lost, update to new session
                _sessionId = result.SessionId;
                Console.WriteLine($"Session was lost, joined new session: {_sessionId}");
                _messages.Add(new ChatMessageDisplay
                {
                    Role = "system",
                    Content = "‚ö†Ô∏è Previous session expired. Started new session.",
                    Timestamp = DateTime.Now
                });
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to rejoin session: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        _dotNetRef?.Dispose();
        
        if (_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    // Helper classes
    private class ChatMessageDisplay
    {
        public string Role { get; set; } = "";
        public string Content { get; set; } = "";
        public string? ToolName { get; set; }
        public string? ToolArgs { get; set; }
        public DateTime Timestamp { get; set; }
        public bool IsScreenshot { get; set; }
        public string? ScreenshotBase64 { get; set; }
        // Sub-agent support
        public int AgentDepth { get; set; } = 0;
        public string? AgentRole { get; set; }
        public bool IsSubAgentDelegation { get; set; }
    }

    private class TokenUsageDisplay
    {
        public int Prompt { get; set; }
        public int Completion { get; set; }
        public int Total { get; set; }
    }

    private class SessionInfo
    {
        public string SessionId { get; set; } = "";
        public int MessageCount { get; set; }
        public ConfigInfo? Config { get; set; }
    }

    private class ConfigInfo
    {
        public string? Model { get; set; }
        public string? HostUrl { get; set; }
        public string? WorkDirectory { get; set; }
        public bool McpEnabled { get; set; }
        public bool RagEnabled { get; set; }
    }

    private class AgentStreamEvent
    {
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("data")]
        public string Data { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("toolName")]
        public string? ToolName { get; set; }
    }

    private class AutocompleteSuggestion
    {
        public string Text { get; set; } = "";
        public string Icon { get; set; } = "üìÑ";
        public string Description { get; set; } = "";
    }

    private class FileContentResult
    {
        public bool Success { get; set; }
        public string Content { get; set; } = "";
        public string? Error { get; set; }
        public bool IsBinary { get; set; }
    }

    // Orchestration data classes
    private class OrchestrationPlanData
    {
        [System.Text.Json.Serialization.JsonPropertyName("taskId")]
        public string TaskId { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("taskName")]
        public string TaskName { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("subtasks")]
        public List<SubtaskInfo> Subtasks { get; set; } = new();
    }

    private class SubtaskInfo
    {
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("title")]
        public string Title { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; } = "";
    }

    private class AgentStartData
    {
        [System.Text.Json.Serialization.JsonPropertyName("agentId")]
        public string AgentId { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("taskId")]
        public string TaskId { get; set; } = "";
    }

    private class AgentOutputData
    {
        [System.Text.Json.Serialization.JsonPropertyName("agentId")]
        public string AgentId { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("taskId")]
        public string TaskId { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("text")]
        public string Text { get; set; } = "";
    }

    private class AgentToolCallData
    {
        [System.Text.Json.Serialization.JsonPropertyName("agentId")]
        public string AgentId { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("taskId")]
        public string TaskId { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("toolName")]
        public string ToolName { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; } = "";
    }

    private class AgentCompleteData
    {
        [System.Text.Json.Serialization.JsonPropertyName("agentId")]
        public string AgentId { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("taskId")]
        public string TaskId { get; set; } = "";
        [System.Text.Json.Serialization.JsonPropertyName("success")]
        public bool Success { get; set; }
        [System.Text.Json.Serialization.JsonPropertyName("result")]
        public string? Result { get; set; }
        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public string? Error { get; set; }
    }

    private class OrchestrationCompleteData
    {
        [System.Text.Json.Serialization.JsonPropertyName("success")]
        public bool Success { get; set; }
    }

    private class ContextUsageDisplay
    {
        [System.Text.Json.Serialization.JsonPropertyName("totalTokens")]
        public int TotalTokens { get; set; }
        [System.Text.Json.Serialization.JsonPropertyName("maxContextLength")]
        public int MaxContextLength { get; set; }
        [System.Text.Json.Serialization.JsonPropertyName("usagePercent")]
        public double UsagePercent { get; set; }
    }
}
